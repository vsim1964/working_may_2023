# Git
Распределённые системы контроля версий: каждая копия репозитория является полным бэкапом всех данных. Для работы большинства операций в Git достаточно локальных файлов и ресурсов.

У Git есть три основных состояния, в которых могут находиться ваши файлы: изменён (modified), индексирован (staged) и зафиксирован (committed):

-  изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы.
- индексированный — это изменённый файл в его текущей версии, отмеченный для включения в следующий коммит.
- зафиксированный значит, что файл уже сохранён в вашей локальной базе.

Мы подошли к трём основным секциям проекта Git: рабочая копия (working tree), область индексирования (staging area) и каталог Git (Git directory).

Рабочая копия является снимком одной версии проекта. Эти файлы извлекаются из сжатой базы данных в каталоге Git и помещаются на диск, для того чтобы их можно было использовать или редактировать.

Базовый подход в работе с Git выглядит так:

- Изменяете файлы вашей рабочей копии.
- Выборочно добавляете в индекс только те изменения, которые должны попасть в следующий коммит, добавляя тем самым снимки только этих изменений в индекс.
- Когда вы делаете коммит, используются файлы из индекса как есть, и этот снимок сохраняется в ваш каталог Git.

## Первая настройка

*Командная строка*
```bash
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
```
*Выбор редактора*
`$ git config --global core.editor emacs`
*Просмотр настроек*
`git config --list`
*Как получить помощь?*
```bash
$ git add -h
$ git help <команда>
$ git help config
```
## Git-репозиторий
```bash
$ git init
$ git add .
$ git add LICENSE
$ git commit -m 'Initial project version'
$ git status
$ git status -s
$ git clone https://github.com/libgit2/libgit2
```
*Игнорирование файлов*
`.gitignore`

*Изменили, но пока не проиндексировали*
`git diff` Эта команда сравнивает содержимое вашего рабочего каталога с содержимым индекса
*Gроиндексировали и войдёт в следующий коммит*
`git diff --staged` Эта команда сравнивает ваши проиндексированные изменения с последним коммитом

*Фиксация без предварительной индексации*
`git commit -a -m 'Comment'`
*Удаление из рабочей папки и из индекса*
`git rm 1.txt`
*Переименование файла*
`git mv file_from file_to`

*Просмотр истории коммитов*
`$ git log`
`$ git log -p -2` оказывает разницу (патч), внесённую в 2 коммита
`$ git log --stat`
`$ git log --pretty=oneline`
`$ git log --pretty=format:"%h - %an, %ar : %s"`
`$ git log --pretty=format:"%h %s" --graph`

*Переносы указателя HEAD*
Два указателя: имя ветки и HEAD. имя ветки всегда показывает на самый свежий коммит (даже тот, что в работе. Для «движения» указателя HEAD существует команда: git checkout.
`$ git checkout hash`
`$ git checkout master`
*Переносы указателя BRANCH-NAME*
`$ git checkout -b name`
*Отследить движение HEAD*
`$ git reflog`

*Операции отмены*
`$ git commit --amend`  переделать коммит — внесите изменения, добавьте их в индекс и сделайте коммит ещё раз
*Отмена индексации файла*
`$ git reset HEAD <file>`
*Отмена изменений в файле*
`$ git checkout -- <file>`
Git версии 2.23.0 представил новую команду: `git restore`
`$ git restore --staged CONTRIBUTING.md` для отмены индексации файла.
`$ git restore --staged CONTRIBUTING.md` Откат изменённого файла

## Работа с удалёнными репозиториями

*Просмотр удалённых репозиториев*
`$ git remote -v`
*Добавление удалённых репозиториев*
`$ git remote add <shortname> <url>:`
*Получение изменений из удалённого репозитория — Fetch и Pull*
`$ git fetch [remote-name]`
`git pull [remote-name]`
*Отправка изменений в удалённый репозиторий (Push)*
`$ git push origin master`
*Просмотр удалённого репозитория*
`$ git remote show origin`
*Удаление и переименование удалённых репозиториев*
`$ git remote rename pb paul`
`$ git remote remove paul`

## Работа с тегами
## Псевдонимы в Git
```bash
$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status
```

## Ветвление в Git
`$ git branch testing` ===  `$ git checkout -b testing`
`$ git checkout testing` HEAD переместится на ветку testing.
`git branch -d hotfix` удаление ветки
`git log --oneline --decorate --graph --all`

Если рабочий каталог либо индекс содержат незафиксированные изменения, конфликтующие с веткой, на которую вы хотите переключиться, то Git не позволит переключить ветки. Лучше всего переключаться из чистого рабочего состояния проекта. Есть способы обойти это (припрятать изменения (stash) или добавить их в последний коммит (amend))

1. Произвел фиксацию и отправку ветки testing
2. На github(origin) - сделал пулл реквести и мерж.
3. Перешл локально на мастер и вытянул смерженные изменения.

*Переименование ветки*
```bash
$ git branch --move bad-branch-name corrected-branch-name
$ git push --set-upstream origin corrected-branch-name
$ git push origin --delete bad-branch-name
$ git branch --move master main
$ git push --set-upstream origin main
$ git push origin --delete master
```


### GitHub
*Создание ответвлений (fork)*
*Рабочий процесс с использованием GitHub*
1. Создайте форк проекта.
2. Клонируем нашу копию
3. Вносим свои изменения // Проверяем изменения
4. Фиксируем изменения в тематической ветке
5. Отправляем новую ветку в нашу копию на GitHub
6.  GitHub заметил наши изменения и предлагает открыть запрос на слияние с помощью большой зелёной кнопки.
[img](https://git-scm.com/book/en/v2/images/blink-02-pr.png)
7. Жмем. Описываемсмысл пулл-реквеста. Делаем запрос
8. Также мы видим список коммитов в нашей тематической ветке, «опередивших» ветку master (в данном случае всего один коммит) и предпросмотр всех изменений, вносимых этими коммитами.
9. Страница обсуждения запроса на слияние
10. Владелец проекта принимает решение о принятии изменений, либо об их отклонении.
11. Получите обновлённую ветку master и
12. отправьте её в свой форк.
